/*
 * main.c
 *
 *  Created on: Apr 25, 2025
 *      Author: Steven Bolt
 */

#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>			// needed for round()
#include "system.h"			// include system header for base addresses
#include "alt_types.h"		// needed for interrupts
#include "sys/alt_irq.h"	// needed for interrupts

// create standard embedded type definitions
typedef   signed char   sint8;              // signed 8 bit values
typedef unsigned char   uint8;              // unsigned 8 bit values
typedef   signed short  sint16;             // signed 16 bit values
typedef unsigned short  uint16;             // unsigned 16 bit values
typedef   signed long   sint32;             // signed 32 bit values
typedef unsigned long   uint32;             // unsigned 32 bit values
typedef         float   real32;             // 32 bit real values

// ssd display values
#define ZERO	0xC0
#define ONE		0xF9
#define TWO		0xA4
#define THREE	0xB0
#define FOUR	0x19
#define FIVE	0x92
#define SIX		0x82
#define SEVEN	0xF8
#define EIGHT	0x80
#define NINE	0x98
#define DASH	0x3F

// servo angle bounds
#define MIN_ANGLE	0x0000C350	// 50,000 counts (45 degrees)
#define MAX_ANGLE	0x000186A0	// 100,000 counts (135 degrees)

#define USEC_PER_DEG	11.11	// microseconds per degree that the servo will travel

// index of display numbers
uint8 dispNums[] = {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE};

volatile uint32* PB_Ptr = (uint32*)PUSHBUTTONS_BASE;	// pointer to pushbuttons base address
volatile uint32* SW_Ptr = (uint32*)SWITCHES_BASE;		// pointer to switches base address
uint32* Servo_Ptr = (uint32*)SWITCHES_BASE;		// pointer to servo controller base address

// ssd display pointers
uint32* HEX0_Ptr = (uint32*)HEX0_BASE;
uint32* HEX1_Ptr = (uint32*)HEX1_BASE;
uint32* HEX2_Ptr = (uint32*)HEX2_BASE;
uint32* HEX3_Ptr = (uint32*)HEX3_BASE;
uint32* HEX4_Ptr = (uint32*)HEX4_BASE;
uint32* HEX5_Ptr = (uint32*)HEX5_BASE;

// global variables
uint8 pb_val = 0x00;
uint32 min_angle = MIN_ANGLE;
bool min_angle_flag = false;
uint32 max_angle = MAX_ANGLE;
bool max_angle_flag = true;


void pb_isr(void *context)
{
	// read edge capture register
	pb_val = *(PB_Ptr + 3);

	// clear interrupt
	*(PB_Ptr + 3) = 0;

	// if KEY3 pressed
	if (pb_val == 0x08)
	{
		// read new minimum angle value from switches and indicate display update
		min_angle = *SW_Ptr;
		min_angle_flag = true;
	}

	// if KEY2 pressed
	if (pb_val == 0x04)
	{
		// read new maximum angle value from switches and indicate display update
		max_angle = *SW_Ptr;
		max_angle_flag = true;
	}

}

void servo_isr(void *context)
{
	// write angles to servo controller registers
	*(Servo_Ptr + 0) = min_angle;
	*(Servo_Ptr + 1) = max_angle;
}

int counts2deg(uint32 counts)
{
	// servo counts to degrees conversion (working in uSecs)

	// multiply by 0.02 (20ns clock)
	// divide by USEC_PER_DEG (11.11us per degree)
	// round result
	// subtract 45 degrees (starting at an angle of 45)
	int degrees = round((counts * 0.02) / USEC_PER_DEG) - 45;

	return degrees;
}

uint32 deg2counts(int degrees)
{
	// degrees to servo counts conversion (working in uSecs)

	// add 45 degrees (starting at an angle of 45)
	// multiply by USEC_PER_DEG (11.11us per degree)
	// round result
	// divide by 0.02 (20ns clock)
	uint32 counts = round((degrees + 45) * USEC_PER_DEG) / 0.02;

	return counts;
}

int main(void)
{
	// min and max string buffers for digit splitting
	char min_buff[3], max_buff[4];

	// enable PB interrupts on KEY2 and KEY3 and assign interrupt handler function
	*(PB_Ptr + 2) = 0x0000000C;
	alt_ic_isr_register(PUSHBUTTONS_IRQ_INTERRUPT_CONTROLLER_ID,PUSHBUTTONS_IRQ,pb_isr,0,0);

	// enable servo controller interrupts
	alt_ic_isr_register(SERVO_CONTROLLER_0_IRQ_INTERRUPT_CONTROLLER_ID,
						SERVO_CONTROLLER_0_IRQ,servo_isr,0,0);

	// initial write of default min and max values to servo controller angle registers and display
	*(Servo_Ptr + 0) = MIN_ANGLE;
	*(Servo_Ptr + 1) = MAX_ANGLE;
	min_angle_flag = true;
	max_angle_flag = true;

	// reset displays
	*HEX0_Ptr = ZERO;
	*HEX1_Ptr = ZERO;
	*HEX2_Ptr = ZERO;
	*HEX3_Ptr = DASH;
	*HEX4_Ptr = FOUR;
	*HEX5_Ptr = EIGHT;

	while(1)
	{
		// if minimum angle has changed
		if (min_angle_flag)
		{
			min_angle_flag = false;

			// write to display
			snprintf(min_buff, 3, "%d", counts2deg(min_angle));	// send to buffer string
			*HEX5_Ptr = dispNums[(int)(min_buff[0] - '0')];		// display 10s digit on HEX5
			*HEX4_Ptr = dispNums[(int)(min_buff[1] - '0')];		// display 1s digit on HEX4
		}

		// if maximum angle has changed
		if (max_angle_flag)
		{
			max_angle_flag = false;

			// write to display
			snprintf(max_buff, 4, "%d", counts2deg(max_angle));	// convert max_angle to a char array
			*HEX2_Ptr = dispNums[(int)(max_buff[0] - '0')];		// display 100s digit on HEX2
			*HEX1_Ptr = dispNums[(int)(max_buff[1] - '0')];		// display 10s digit on HEX1
			*HEX0_Ptr = dispNums[(int)(max_buff[2] - '0')];		// display 1s digit on HEX0
		}
	}

	return 0;
}
